#!/usr/bin/env python
import requests
import re
import urllib.parse
from bs4 import BeautifulSoup


class Scanner:
    def __init__(self,url,ignore_links):
        self.session=requests.Session() # represent current session, everything will be done through out the session
        self.target_url=url
        self.target_links=[]
        self.links_ingore=ignore_links

    def extract_links(self,url):
        response = self.session.get(url)
        re_code='(?:href=")(.*?)"'
        return re.findall(re_code.encode(), response.content)
        # return re.findall('(?:href=")(.*?)"',response.content.decode(errors="ignore")) # incase of python3
        # error=ignore to tell python to overlook error in case of decode

    def crawl(self,url=None): # default value of url is none, can call the method without specifying the url
        if url==None:
            url=self.target_url # if the method is called without the url, it checks and set the url to target url
        href_links = self.extract_links(url)
        for i in href_links: # i is the link
            i = urllib.parse.urljoin(url, i.decode()) # only completes the incomplete links leaves the rest
            if '#' in i:
                i = i.split('#')[0]
            if self.target_url in i and i not in self.target_links and i not in self.links_ingore:
                # won't crawl the ignored links cause we don't wanna stop process
                self.target_links.append(i)
                print(i)
                self.crawl(i)  # recursive function to crawl within the link, to crawl everything in website

    def extract_forms(self,url):
        response = self.session.get(url)
        # parse the html code using beautifulsoup
        parsed_html = BeautifulSoup(response.content,'html.parser')  # using this to access different part of html page
        return parsed_html.findAll("form")  # element in the form is given, with all the nested elements

    def submit_for(self,form,value,url): # submit the forms
        # .get to get the attributes
        action = form.get("action")
        post_url = urllib.parse.urljoin(url, action)  # to complete the url
        # print(post_url)
        method = form.get("method")
        # print(method)
        # need the input names to build the dictionary
        input_list = form.findAll("input")
        post_data = {}  # creating a dictionary to pass the value
        for input in input_list:
            # getting the attributes in the attribute
            input_name = input.get("name")
            # print(input_name)
            input_type = input.get("type")
            input_value = input.get("value")  # default value just in case
            if input_type == "text":
                input_value = value
            post_data[input_name] = input_value

        # mostly use post method not all
        if method=="post":
            return self.session.post(post_url, data=post_data)  # passing the value to the url
        return self.session.get(post_url,params=post_data) # for the site's which uses get method


    # to discover any vulnerability generically add here
    def run_scanner(self):
        for link in self.target_links:
            forms=self.extract_forms(link)

            # adding different form of vulnerability scanner - here XSS, can increase further
            for form in forms:
                print("[+] Testing form in "+link)
                is_vulnerable_to_xss=self.test_xss_in_form(form,link)
                if is_vulnerable_to_xss:
                    print("\n\n-----> XSS discovered in "+link+" in following form")
                    print(form)
                    print("\n")

            if "=" in link: # means it send data through web application
                print("[+] Testing " + link)
                is_vulnerable_to_xss=self.test_xss_in_link(link)
                if is_vulnerable_to_xss:
                    print("\n\n-----> Discovered XSS in "+link)

    # add any function code u want in here and call it, generic way to add other functionality

# DISCOVERING XSS VULNERABILITIES

# XSS is executed on client side not the server
# inject js code in to the page
# 3 types- persistent/Stored XSS, Reflected XSS, DOM based XSS
# discovering XSS- try injection, test text boxes and url parameters
# reflected XSS- non persistent, not stored, only work if the target visits specific url
# stored XSS- persistent, stored on the page or DB, injected code is executed everytime the page is loaded
    def test_xss_in_form(self,form,url):
        xss_test_script="<sCript>alert('hello')</scriPt>" # changing the capitalization of the cod eto bypass filters
        response=self.submit_for(form,xss_test_script,url) # submitting form with xss value to the url
        return xss_test_script.encode() in response.content

    # as we can pass the XSS vuln through the link too, not just forms
    def test_xss_in_link(self,url):
        xss_test_script="<sCript>alert('hello')</scriPt>"
        url=url.replace("=","="+xss_test_script)
        response=self.session.get(url)
        return xss_test_script.encode() in response.content
